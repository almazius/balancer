Балансировщик нагрузки на golang

[TODO] Балансирует нагрузку между набором из N сервисов. Набор необходимо уметь изменять без перезапуска сервиса, через хттп-ручки. Добавлять, удалять. Эти ручки должны быть с jwt авторизацией.

[X] Необходимо реализовать несколько алгоритмов балансировки. Round robin, случайный, кол-во обрабатываемых в данный момент запросов, среднее время ответа сервера (за последние 5 минут). Алгоритм также необходимо иметь возможность менять на лету через хттп-ручку с той же jwt авторизацией.

[X] Надо иметь возможность настраивать кеширование. Если оно включено, то для запросов с идентичными путём запроса, хедерами и телом запроса будет возвращено значение из кеша. Включать-выключать на лету через ручку.

[X] Очевидно, нужно максимизировать нагрузоустойчивость и пропускную способность самого балансера. На сделанный вами выбор инструментов (например, какой сервер использовать) будет обращено внимание. Также, естественно, на сам код - насколько он ориентирован на хайлод, как эффективно пользуетесь инструментами языка и библиотек.

[X] Балансировать не только хттп-запросы, но и grpc-запросы. Так как grpc построен на хттп, это, возможно, не так уж и сложно.

[X] Нужна тажке ручка, которая вернёт в формате json текущую конфигурацию балансировщика. Как именно структурировать этот жсон - ваше дело.

[X] Для всего админского функционала балансировщика (все вышеупомянутые ручки) должна быть openapi документация.

[X] Необходимо логировать все запросы, которые проксируются. Логировать путь запроса, сервис, куда запрос проксирован, и тело запроса. Выбор логгера также имеет воздействие на производительность - он будет учитываться.

[X] Кодовая база должна быть абстрагирована от какой-либо конкретной либы логирования. Изменения в реализации логгера не должны провоцировать изменения в реализации остальных частей программы.

[X] Должен быть настроен линтер. Любой удобный. Правила линтера можно спереть из большой компании типа убера, или с любого опен сорс проекта.

[X] Всё обернуть в контейнер. В докерфайле необходимо реализовать слой кеша зависимостей (dependency cache).

[X] Деплой через docker compose. Можно написать скриптик для деплоя локально на ноут, арендовать сервер не надо :)

[X] Залить на gitlab и настроить ci: джоба для прогона тестов, джоба для статического анализа кода, джоба для билда образа и загрузки его в реестр гитлаба. Без успешных тестов и статического анализа билд не начнётся. Джобы должны прогонятся автоматом в релизной ветке, и вручную во всех остальных ветках.



## ПОПЫТКА №1

хранение данных in-memory, fiber в качестве сервера